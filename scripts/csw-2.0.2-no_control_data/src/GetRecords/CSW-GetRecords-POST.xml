<?xml version="1.0" encoding="UTF-8"?>
<ctl:package xmlns="http://www.occamlab.com/ctl" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:ctl="http://www.occamlab.com/ctl" xmlns:parsers="http://www.occamlab.com/te/parsers"
	xmlns:p="http://teamengine.sourceforge.net/parsers" xmlns:saxon="http://saxon.sf.net/"
	xmlns:csw="http://www.opengis.net/cat/csw/2.0.2" xmlns:gml="http://www.opengis.net/gml"
	xmlns:ogc="http://www.opengis.net/ogc" xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:dct="http://purl.org/dc/terms/" xmlns:xi="http://www.w3.org/2001/XInclude">

	<ctl:test name="csw:GetRecords-POST">
		<param name="csw.capabilities.doc"/>
		<ctl:assertion> A conforming implementation must satisfy all assertions for GetRecords XML
			requests using the POST method. </ctl:assertion>
		<ctl:code>
			<xsl:variable name="csw.GetRecords.post.url">
				<xsl:value-of
					select="$csw.capabilities.doc//ows:OperationsMetadata/ows:Operation[@name='GetRecords']/ows:DCP/ows:HTTP/ows:Post/@xlink:href"
				/>
			</xsl:variable>
			<ctl:message>Target endpoint is <xsl:value-of select="$csw.GetRecords.post.url"/></ctl:message>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc1.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc2.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc2.2">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc3.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc4.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc4.2">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc5.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc5.2">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc6.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc6.2">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc7.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc8.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc8.2">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc9.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc10.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc11.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc11.2">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc12.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc13.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc14.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc14.2">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc15.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc16.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc16.2">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc17.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc17.2">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc18.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc19.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc20.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc21.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc22.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc23.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc24.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc25.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
			<ctl:call-test name="csw:csw-2.0.2-GetRecords-tc26.1">
				<ctl:with-param name="csw.GetRecords.post.url" select="$csw.GetRecords.post.url"/>
			</ctl:call-test>
		</ctl:code>
	</ctl:test>

	<test name="csw:csw-2.0.2-GetRecords-tc1.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> A GetRecords request that omits all optional elements must produce a response
			containing only a summary of the result set. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element is empty.</comment>
		<code>
			<ctl:message>GetRecords URL <xsl:value-of select="$csw.GetRecords.post.url"
				/></ctl:message>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords xmlns:csw="http://www.opengis.net/cat/csw/2.0.2"
							service="CSW" version="2.0.2">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>brief</csw:ElementSetName>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:call-test name="ctl:SchematronValidatingParser">
						<ctl:with-param name="doc" select="$response"/>
						<ctl:with-param name="schema">sch/csw/2.0.2/GetRecords.sch</ctl:with-param>
						<ctl:with-param name="phase">DefaultPhase</ctl:with-param>
					</ctl:call-test>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc2.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that specifies a "summary" view must
			include the corresponding record representations not exceeding the value of the default
			maxRecords attribute (10). </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains exactly 10 csw:SummaryRecord child
			elements</comment>
		<code>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>summary</csw:ElementSetName>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:call-test name="ctl:SchematronValidatingParser">
						<ctl:with-param name="doc" select="$response"/>
						<ctl:with-param name="schema">sch/csw/2.0.2/GetRecords.sch</ctl:with-param>
						<ctl:with-param name="phase">TenRecordsPhase</ctl:with-param>
					</ctl:call-test>
					<xsl:variable name="nMatches">
						<xsl:value-of select="$response//csw:SearchResults/@numberOfRecordsMatched"
						/>
					</xsl:variable>
					<xsl:if
						test="count($response/csw:GetRecordsResponse/csw:SearchResults/csw:SummaryRecord) != 10">
						<ctl:message>[FAILURE] 10 csw:SummaryRecord elements expected in
							response.</ctl:message>
						<ctl:fail/>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc2.2">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that specifies a "brief" view must include
			the corresponding record representations not exeeding the value of the default
			maxRecords attribute (10) or the maxiumum number of records in the database if it is
			less than 10. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains exactly 10 csw:BriefRecord child elements if
			in the DB there are more than 10 records, otherways expect the maximum number of
			records..</comment>
		<code>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>brief</csw:ElementSetName>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:call-test name="ctl:SchematronValidatingParser">
						<ctl:with-param name="doc" select="$response"/>
						<ctl:with-param name="schema">sch/csw/2.0.2/GetRecords.sch</ctl:with-param>
						<ctl:with-param name="phase">TenRecordsPhase</ctl:with-param>
					</ctl:call-test>
					<xsl:variable name="nMatches">
						<xsl:value-of select="$response//csw:SearchResults/@numberOfRecordsMatched"
						/>
					</xsl:variable>
					<xsl:choose>
						<xsl:when test="xsd:integer($nMatches) lt 10">
							<ctl:message>[WARNING] There are less than 10 records, the test will
								work anyway but for best results use at least 11
								records</ctl:message>
							<xsl:if
								test="count($response/csw:GetRecordsResponse/csw:SearchResults/csw:BriefRecord) != $nMatches">
								<ctl:message>[FAILURE] <xsl:value-of select="$nMatches"/>
									csw:BriefRecord elements expected in response.</ctl:message>
								<ctl:fail/>
							</xsl:if>
						</xsl:when>
						<xsl:otherwise>
							<xsl:if
								test="count($response/csw:GetRecordsResponse/csw:SearchResults/csw:BriefRecord) != 10">
								<ctl:message>[FAILURE] 10 csw:BriefRecord elements expected in
									response.</ctl:message>
								<ctl:fail/>
							</xsl:if>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc3.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that specifies an ad hoc view must include
			the corresponding csw:Record representations not exeeding the value of the default
			maxRecords attribute (10). </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains exactly 10 csw:Record child elements, each
			containing only the requested elements.</comment>
		<code>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords xmlns:csw="http://www.opengis.net/cat/csw/2.0.2"
							service="CSW" version="2.0.2" resultType="results">
							<csw:Query xmlns:dc="http://purl.org/dc/elements/1.1/"
								xmlns:dct="http://purl.org/dc/terms/" typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:type</csw:ElementName>
								<csw:ElementName>dc:date</csw:ElementName>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:for-each select="$response//csw:Record/*">
						<xsl:variable name="local-name" select="local-name(.)"/>
						<xsl:if test="empty(index-of(('identifier', 'type', 'date'), $local-name))">
							<ctl:message>[FAILURE] Unexpected record property: <xsl:value-of
									select="$local-name"/> (<xsl:value-of select="../dc:identifier"
								/>)</ctl:message>
							<ctl:fail/>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc4.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that specifies sorting criteria must
			include the corresponding record representations in the correct sort order. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains exactly 10 csw:BriefRecord child elements or
			the maxiumum number of records in the database if they are less than 10.; (3) the
			records are sorted by dc:identifier in ascending order.</comment>
		<code>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>brief</csw:ElementSetName>
								<ogc:SortBy>
									<ogc:SortProperty>
										<ogc:PropertyName>dc:identifier</ogc:PropertyName>
										<ogc:SortOrder>ASC</ogc:SortOrder>
									</ogc:SortProperty>
								</ogc:SortBy>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:call-test name="ctl:SchematronValidatingParser">
						<ctl:with-param name="doc" select="$response"/>
						<ctl:with-param name="schema">sch/csw/2.0.2/GetRecords.sch</ctl:with-param>
						<ctl:with-param name="phase">TenRecordsPhase</ctl:with-param>
					</ctl:call-test>

					<xsl:variable name="nMatches">
						<xsl:value-of select="$response//csw:SearchResults/@numberOfRecordsMatched"
						/>
					</xsl:variable>
					<xsl:choose>
						<xsl:when test="xsd:integer($nMatches) lt 10">
							<ctl:message>[WARNING] There are less than 10 records, the test will
								work anyway but for best results use at least 11
								records</ctl:message>
							<xsl:if
								test="count($response/csw:GetRecordsResponse/csw:SearchResults/csw:BriefRecord) != $nMatches">
								<ctl:message>[FAILURE] <xsl:value-of select="$nMatches"/>
									csw:BriefRecord elements expected in response.</ctl:message>
								<ctl:fail/>
							</xsl:if>
						</xsl:when>
						<xsl:otherwise>
							<xsl:if
								test="count($response/csw:GetRecordsResponse/csw:SearchResults/csw:BriefRecord) != 10">
								<ctl:message>[FAILURE] 10 csw:BriefRecord elements expected in
									response.</ctl:message>
								<ctl:fail/>
							</xsl:if>
						</xsl:otherwise>
					</xsl:choose>

					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:variable name="actual-node" select="dc:identifier"/>
						<xsl:if test="./preceding-sibling::node()/dc:identifier">
							<xsl:variable name="preceding-sibling"
								select="./preceding-sibling::node()[2]/dc:identifier"/>
							<xsl:if test="compare($preceding-sibling,$actual-node) ne -1">
								<ctl:message>[FAILURE] Search results are not sorted correctly by
									dc:identifier in ascending order.</ctl:message>
								<ctl:fail/>
							</xsl:if>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc4.2">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that specifies an ad hoc view and sorting
			criteria must include the corresponding csw:Record representations in the correct sort
			order. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains exactly 10 csw:BriefRecord child elements or
			the maxiumum number of records in the database if they are less than 10.; (3) the
			records are sorted by dc:date in descending order.</comment>
		<code>
			<!--<ctl:message>Inizio richiesta data</ctl:message>-->
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:type</csw:ElementName>
								<csw:ElementName>dc:date</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsGreaterThanOrEqualTo>
											<ogc:PropertyName>dc:date</ogc:PropertyName>
											<ogc:Literal>0000-00-00</ogc:Literal>
										</ogc:PropertyIsGreaterThanOrEqualTo>
									</ogc:Filter>
								</csw:Constraint>
								<ogc:SortBy>
									<ogc:SortProperty>
										<ogc:PropertyName>dc:date</ogc:PropertyName>
										<ogc:SortOrder>DESC</ogc:SortOrder>
									</ogc:SortProperty>
								</ogc:SortBy>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>
			<xsl:variable name="nMatches">
				<xsl:value-of select="$response//csw:SearchResults/@numberOfRecordsMatched"/>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:message select="$response"/>
					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:variable name="local-name" select="local-name(.)"/>
						<xsl:if test="index-of(('date'), $local-name) eq 3">
							<ctl:message>[FAILURE] Unexpected record property: <xsl:value-of
									select="$local-name"/> (<xsl:value-of select="../dc:identifier"
								/>)</ctl:message>
							<ctl:fail/>
						</xsl:if>
						<xsl:variable name="actual-node" select="dc:date"/>
						<xsl:if test="./preceding-sibling::node()/dc:date">
							<xsl:variable name="preceding-sibling"
								select="./preceding-sibling::node()[2]/dc:date"/>
							<xsl:if test="xsd:date($actual-node) gt xsd:date($preceding-sibling)">
								<ctl:message>[FAILURE] Search results are not sorted correctly by
									dc:identifier in ascending order.</ctl:message>
								<ctl:fail/>
							</xsl:if>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc5.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having a BBOX
			operator must include all matching record representations. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains 1-10 matching csw:Record child
			elements.</comment>
		<code>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords xmlns:csw="http://www.opengis.net/cat/csw/2.0.2"
							service="CSW" version="2.0.2" resultType="results">
							<csw:Query xmlns:dc="http://purl.org/dc/elements/1.1/"
								xmlns:ows="http://www.opengis.net/ows" typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>ows:BoundingBox</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc"
										xmlns:gml="http://www.opengis.net/gml">
										<ogc:BBOX>
											<ogc:PropertyName>/ows:BoundingBox</ogc:PropertyName>
											<gml:Envelope srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
												<gml:lowerCorner>47.0 -4.5</gml:lowerCorner>
												<gml:upperCorner>52.0 1.0</gml:upperCorner>
											</gml:Envelope>
										</ogc:BBOX>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:call-test name="ctl:SchematronValidatingParser">
						<ctl:with-param name="doc" select="$response"/>
						<ctl:with-param name="schema">sch/csw/2.0.2/GetRecords.sch</ctl:with-param>
						<ctl:with-param name="phase">OneToTenRecordsPhase</ctl:with-param>
					</ctl:call-test>
					<xsl:if
						test="count($response//csw:SearchResults/csw:Record) != count($response//csw:SearchResults/*)">
						<ctl:message>[FAILURE] Only csw:Record elements expected in
							response.</ctl:message>
						<ctl:fail/>
					</xsl:if>
					<xsl:variable name="env">
						<gml:Envelope srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
							<gml:lowerCorner>47.0 -4.5</gml:lowerCorner>
							<gml:upperCorner>52.0 1.0</gml:upperCorner>
						</gml:Envelope>
					</xsl:variable>
					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:if test="csw:disjoint-envelopes($env,ows:BoundingBox) != 0">
							<ctl:message>[FAILURE] Envelopes do NOT intersect or @srsName value does
								not match 'urn:x-ogc:def:crs:EPSG:6.11:4326'(<xsl:value-of
									select="dc:identifier"/>)</ctl:message>
							<ctl:fail/>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc5.2">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having a
			spatial operator that does not refer to a geometry-valued property must include an
			exception report. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is a valid
			ows:ExceptionReport; (2) the reported exceptionCode is
			"InvalidParameterValuePhase".</comment>
		<code>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords xmlns:csw="http://www.opengis.net/cat/csw/2.0.2"
							service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>brief</csw:ElementSetName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc"
										xmlns:gml="http://www.opengis.net/gml">
										<ogc:BBOX>
											<ogc:PropertyName xmlns:dct="http://purl.org/dc/terms/"
												>dct:spatial</ogc:PropertyName>
											<gml:Envelope srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
												<gml:lowerCorner>47.0 -4.5</gml:lowerCorner>
												<gml:upperCorner>52.0 1.0</gml:upperCorner>
											</gml:Envelope>
										</ogc:BBOX>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.OWS/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:call-test name="ctl:SchematronValidatingParser">
						<ctl:with-param name="doc" select="$response"/>
						<ctl:with-param name="schema"
							>sch/ows/1.0.0/ExceptionReport.sch</ctl:with-param>
						<ctl:with-param name="phase">InvalidParameterValuePhase</ctl:with-param>
					</ctl:call-test>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc6.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having a
			PropertyIsEqualTo predicate (case-sensitive by default) must include all matching record
			representations. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains exactly one matching csw:BriefRecord
			instance; (3) csw:SearchResults/@nextRecord="0" </comment>
		<code>
			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:title</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsGreaterThan>
											<ogc:PropertyName>dc:title</ogc:PropertyName>
											<ogc:Literal>' '</ogc:Literal>
										</ogc:PropertyIsGreaterThan>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<xsl:variable name="id.1">
				<xsl:value-of select="$response0//csw:SearchResults/*[1]/dc:identifier"/>
			</xsl:variable>
			<xsl:variable name="title.1">
				<xsl:value-of select="$response0//csw:SearchResults/*[1]/dc:title"/>
			</xsl:variable>
			<ctl:message>Titolo letto:</ctl:message>
			<ctl:message select="$title.1"/>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>brief</csw:ElementSetName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsEqualTo>
											<ogc:PropertyName>dc:title</ogc:PropertyName>
											<ogc:Literal>
												<xsl:value-of select="$title.1"/>
											</ogc:Literal>
										</ogc:PropertyIsEqualTo>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>
			<!--<ctl:message select="$id.1"/>
			<ctl:message>response:</ctl:message>
			<ctl:message select="$response"/>
			<ctl:message select="$response//csw:SearchResults//dc:identifier"/>-->

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="$response//csw:SearchResults//dc:title != $title.1">
						<ctl:message>[FAILURE] Expected record has wrong title(<xsl:value-of
								select="string($id.1)"/>).</ctl:message>
						<ctl:fail/>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc6.2">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having a
			PropertyIsEqualTo predicate (case-insensitive) must include all matching record
			representations. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains exactly one matching csw:BriefRecord
			instance.</comment>
		<code>
			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:subject</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsGreaterThan>
											<ogc:PropertyName>dc:subject</ogc:PropertyName>
											<ogc:Literal>' '</ogc:Literal>
										</ogc:PropertyIsGreaterThan>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<xsl:variable name="id.1">
				<xsl:value-of select="$response0//csw:SearchResults/*[1]/dc:identifier"/>
			</xsl:variable>
			<xsl:variable name="subject" select="$response0//csw:SearchResults/*[1]/dc:subject"/>
			<ctl:message>Titolo letto:</ctl:message>
			<ctl:message select="$id.1"/>
			<ctl:message select="$subject"/>
			<!--need to discover if the title has lower or upper case-->
			<xsl:variable name="response">
				<xsl:choose>
					<xsl:when test="matches($subject,'[A-Z]')">
						<ctl:message>Ha maiuscole <xsl:value-of select="lower-case($subject)"
							/></ctl:message>
						<!--il titolo ha delle minuscole, ne ottengo uno sicuramente diverso trasformandole tutte in maiuscole-->
						<request>
							<url>
								<xsl:value-of select="$csw.GetRecords.post.url"/>
							</url>
							<method>POST</method>
							<body>
								<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
									<csw:Query typeNames="csw:Record">
										<csw:ElementName>dc:identifier</csw:ElementName>
										<csw:ElementName>dc:subject</csw:ElementName>
										<csw:Constraint version="1.1.0">
											<ogc:Filter>
												<ogc:PropertyIsEqualTo matchCase="false">
												<ogc:PropertyName>dc:subject</ogc:PropertyName>
												<ogc:Literal>
												<xsl:value-of select="lower-case($subject)"/>
												</ogc:Literal>
												</ogc:PropertyIsEqualTo>
											</ogc:Filter>
										</csw:Constraint>
									</csw:Query>
								</csw:GetRecords>
							</body>
							<p:XMLValidatingParser.CSW/>
						</request>
					</xsl:when>
					<xsl:otherwise>
						<request>
							<url>
								<xsl:value-of select="$csw.GetRecords.post.url"/>
							</url>
							<method>POST</method>
							<body>
								<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
									<csw:Query typeNames="csw:Record">
										<csw:ElementName>dc:identifier</csw:ElementName>
										<csw:ElementName>dc:subject</csw:ElementName>
										<csw:Constraint version="1.1.0">
											<ogc:Filter>
												<ogc:PropertyIsEqualTo matchCase="false">
												<ogc:PropertyName>dc:subject</ogc:PropertyName>
												<ogc:Literal>
												<xsl:value-of select="upper-case($subject)"/>
												</ogc:Literal>
												</ogc:PropertyIsEqualTo>
											</ogc:Filter>
										</csw:Constraint>
									</csw:Query>
								</csw:GetRecords>
							</body>
							<p:XMLValidatingParser.CSW/>
						</request>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>

					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:choose>
							<xsl:when test="lower-case(dc:subject) = lower-case($subject)"/>
							<xsl:otherwise>
								<ctl:message>[FAILURE] Wrong record returned (<xsl:value-of
										select="dc:subject"/>).</ctl:message>
								<ctl:fail/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc7.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an unsupported function must
			include an exception report. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is a valid
			ows:ExceptionReport; (2) the reported exceptionCode is "InvalidParameterValue"
			(ogc:Function/@name).</comment>
		<code>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords xmlns:csw="http://www.opengis.net/cat/csw/2.0.2"
							service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>brief</csw:ElementSetName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter xmlns:ogc="http://www.opengis.net/ogc"
										xmlns:gml="http://www.opengis.net/gml">
										<ogc:PropertyIsEqualTo>
											<ogc:PropertyName
												xmlns:dc="http://purl.org/dc/elements/1.1/"
												>dc:title</ogc:PropertyName>
											<ogc:Function name="DummyFunction">
												<ogc:Literal>input.argument</ogc:Literal>
											</ogc:Function>
										</ogc:PropertyIsEqualTo>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.OWS/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:call-test name="ctl:SchematronValidatingParser">
						<ctl:with-param name="doc" select="$response"/>
						<ctl:with-param name="schema"
							>sch/ows/1.0.0/ExceptionReport.sch</ctl:with-param>
						<ctl:with-param name="phase">InvalidParameterValuePhase</ctl:with-param>
					</ctl:call-test>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc8.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having a
			PropertyIsNotEqualTo predicate (case-sensitive by default) must exclude matching record
			representations. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element does NOT contain any records with a matching
			title.</comment>
		<code>
			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:title</csw:ElementName>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<xsl:variable name="id.1">
				<xsl:value-of select="$response0//csw:SearchResults/*[1]/dc:identifier"/>
			</xsl:variable>
			<xsl:variable name="title.1" select="$response0//csw:SearchResults/*[1]/dc:title"/>
			<ctl:message>Titolo letto:</ctl:message>
			<ctl:message select="$id.1"/>
			<ctl:message select="$title.1"/>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results"
							maxRecords="100">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>brief</csw:ElementSetName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsNotEqualTo>
											<ogc:PropertyName>dc:title</ogc:PropertyName>
											<ogc:Literal>
												<xsl:value-of select="$title.1"/>
											</ogc:Literal>
										</ogc:PropertyIsNotEqualTo>
									</ogc:Filter>
								</csw:Constraint>
								<ogc:SortBy>
									<ogc:SortProperty>
										<ogc:PropertyName>dc:format</ogc:PropertyName>
										<ogc:SortOrder>DESC</ogc:SortOrder>
									</ogc:SortProperty>
								</ogc:SortBy>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:if test="dc:title eq $title.1">
							<ctl:message>[FAILURE] Unexpected record is included (<xsl:value-of
									select="$id.1"/>).</ctl:message>
							<ctl:fail/>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc8.2">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having a
			PropertyIsNotEqualTo predicate (case-insensitive) must exclude matching record
			representations. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element does NOT contain any records with a matching
			subject.</comment>
		<code>
			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:subject</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsGreaterThan>
											<ogc:PropertyName>dc:subject</ogc:PropertyName>
											<ogc:Literal>' '</ogc:Literal>
										</ogc:PropertyIsGreaterThan>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<xsl:variable name="id.1">
				<xsl:value-of select="$response0//csw:SearchResults/*[1]/dc:identifier"/>
			</xsl:variable>
			<xsl:variable name="subject" select="$response0//csw:SearchResults/*[1]/dc:subject"/>
			<ctl:message>Titolo letto:</ctl:message>
			<ctl:message select="$id.1"/>
			<ctl:message select="$subject"/>
			<!--need to discover if the title has lower or upper case-->
			<xsl:variable name="response">
				<xsl:choose>
					<xsl:when test="matches($subject,'[A-Z]')">
						<!--il titolo ha delle minuscole, ne ottengo uno sicuramente diverso trasformandole tutte in maiuscole-->
						<request>
							<url>
								<xsl:value-of select="$csw.GetRecords.post.url"/>
							</url>
							<method>POST</method>
							<body>
								<csw:GetRecords service="CSW" version="2.0.2" resultType="results"
									maxRecords="20">
									<csw:Query typeNames="csw:Record">
										<csw:ElementSetName>brief</csw:ElementSetName>
										<csw:Constraint version="1.1.0">
											<ogc:Filter>
												<ogc:PropertyIsNotEqualTo matchCase="false">
												<ogc:PropertyName>dc:subject</ogc:PropertyName>
												<ogc:Literal>
												<xsl:value-of select="lower-case($subject)"/>
												</ogc:Literal>
												</ogc:PropertyIsNotEqualTo>
											</ogc:Filter>
										</csw:Constraint>
									</csw:Query>
								</csw:GetRecords>
							</body>
							<p:XMLValidatingParser.CSW/>
						</request>
					</xsl:when>
					<xsl:otherwise>
						<request>
							<url>
								<xsl:value-of select="$csw.GetRecords.post.url"/>
							</url>
							<method>POST</method>
							<body>
								<csw:GetRecords service="CSW" version="2.0.2" resultType="results"
									maxRecords="20">
									<csw:Query typeNames="csw:Record">
										<csw:ElementSetName>brief</csw:ElementSetName>
										<csw:Constraint version="1.1.0">
											<ogc:Filter>
												<ogc:PropertyIsNotEqualTo matchCase="false">
												<ogc:PropertyName>dc:subject</ogc:PropertyName>
												<ogc:Literal>
												<xsl:value-of select="upper-case($subject)"/>
												</ogc:Literal>
												</ogc:PropertyIsNotEqualTo>
											</ogc:Filter>
										</csw:Constraint>
									</csw:Query>
								</csw:GetRecords>
							</body>
							<p:XMLValidatingParser.CSW/>
						</request>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:variable name="recordCount"
						select="count($response//csw:SearchResults/csw:BriefRecord)"/>
					<xsl:if test="$recordCount gt 20">
						<ctl:message>[FAILURE] A maximum of 20 csw:BriefRecord elements expected in
							response (<xsl:value-of select="$recordCount"/> included)</ctl:message>
						<ctl:fail/>
					</xsl:if>
					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:if test="compare(upper-case(dc:subject),upper-case($subject)) = 0">
							<ctl:message>[FAILURE] Unexpected record having dc:subject matching
									<xsl:value-of select="$subject"/> (case-insensitive) -
									(<xsl:value-of select="dc:identifier"/>)</ctl:message>
							<ctl:fail/>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc9.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having a
			PropertyIsGreaterThan predicate must include matching record representations. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains 1-10 csw:Record child elements having
			dc:identifier values grater than dc:identifier of a record that occour in the middle
			position of a list where a record are ordered by identifier</comment>
		<code>
			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<ogc:SortBy>
									<ogc:SortProperty>
										<ogc:PropertyName>dc:identifier</ogc:PropertyName>
										<ogc:SortOrder>DESC</ogc:SortOrder>
									</ogc:SortProperty>
								</ogc:SortBy>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<xsl:variable name="matches.1"
				select="$response0//csw:SearchResults/@numberOfRecordsReturned"/>
			<xsl:variable name="middle" select="floor($matches.1 div 2)"/>
			<ctl:message>risposta0:</ctl:message>
			<ctl:message select="$response0"/>
			<ctl:message select="$middle"/>
			<xsl:variable name="id" select="$response0//csw:SearchResults/*[$middle]/dc:identifier"/>
			<ctl:message>selected id</ctl:message>
			<ctl:message select="$id"/>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:type</csw:ElementName>
								<csw:ElementName>dc:date</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsGreaterThan>
											<ogc:PropertyName>dc:identifier</ogc:PropertyName>
											<ogc:Literal>
												<xsl:value-of select="$id"/>
											</ogc:Literal>
										</ogc:PropertyIsGreaterThan>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>
			<ctl:message select="$response"/>
			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:call-test name="ctl:SchematronValidatingParser">
						<ctl:with-param name="doc" select="$response"/>
						<ctl:with-param name="schema">sch/csw/2.0.2/GetRecords.sch</ctl:with-param>
						<ctl:with-param name="phase">OneToTenRecordsPhase</ctl:with-param>
					</ctl:call-test>
					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:if test="dc:identifier le $id">
							<ctl:message>[FAILURE] Included record with id equal or less
									<xsl:value-of select="$id"/> (<xsl:value-of
									select="dc:identifier"/>)</ctl:message>
							<ctl:fail/>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc10.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having a
			PropertyIsLessThan predicate must include matching record representations. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains 1-10 csw:Record child elements having
			dc:identifier values lesser than dc:identifier of a record that occour in the middle
			position of a list where a record are ordered by identifier</comment>
		<code>
			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<ogc:SortBy>
									<ogc:SortProperty>
										<ogc:PropertyName>dc:identifier</ogc:PropertyName>
										<ogc:SortOrder>DESC</ogc:SortOrder>
									</ogc:SortProperty>
								</ogc:SortBy>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<xsl:variable name="matches.1"
				select="$response0//csw:SearchResults/@numberOfRecordsReturned"/>
			<xsl:variable name="middle" select="floor($matches.1 div 2)"/>
			<ctl:message>risposta0:</ctl:message>
			<ctl:message select="$response0"/>
			<ctl:message select="$middle"/>
			<xsl:variable name="id" select="$response0//csw:SearchResults/*[$middle]/dc:identifier"/>
			<ctl:message>selected id</ctl:message>
			<ctl:message select="$id"/>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:type</csw:ElementName>
								<csw:ElementName>dc:date</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsLessThan>
											<ogc:PropertyName>dc:identifier</ogc:PropertyName>
											<ogc:Literal>
												<xsl:value-of select="$id"/>
											</ogc:Literal>
										</ogc:PropertyIsLessThan>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>
			<ctl:message>Response</ctl:message>
			<ctl:message select="$response"/>
			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:call-test name="ctl:SchematronValidatingParser">
						<ctl:with-param name="doc" select="$response"/>
						<ctl:with-param name="schema">sch/csw/2.0.2/GetRecords.sch</ctl:with-param>
						<ctl:with-param name="phase">OneToTenRecordsPhase</ctl:with-param>
					</ctl:call-test>
					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:if test="dc:identifier ge $id">
							<ctl:message>[FAILURE] Included record id is equal or after
									<xsl:value-of select="$id"/> (<xsl:value-of
									select="dc:identifier"/>)</ctl:message>
							<ctl:fail/>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc11.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having a
			PropertyIsLike predicate must include matching record representations. </assertion>
		<comment>Pass if the csw:SearchResults element contains only csw:SummaryRecord instances
			having a dc:title value starting with a dynamic readed string. This string is obtained
			by reading the title of the first record and sobstiting the last 1/4 of its charachters
			with the symbol of wildcard</comment>
		<code>
			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:title</csw:ElementName>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<xsl:variable name="id.1">
				<xsl:value-of select="$response0//csw:SearchResults/*[1]/dc:identifier"/>
			</xsl:variable>
			<xsl:variable name="title.1" select="$response0//csw:SearchResults/*[1]/dc:title"/>
			<ctl:message select="$response0"/>
			<ctl:message>Titolo letto:</ctl:message>
			<ctl:message select="$id.1"/>
			<ctl:message select="$title.1"/>
			<xsl:variable name="position"
				select="string-length($title.1) - floor(string-length($title.1) div 4)"/>
			<xsl:variable name="truncatedTitle" select="concat(substring($title.1,1,$position),'*')"/>
			<ctl:message select="$truncatedTitle"/>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>summary</csw:ElementSetName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsLike wildCard="*" singleChar="?"
											escapeChar="\">
											<ogc:PropertyName>dc:title</ogc:PropertyName>
											<ogc:Literal>
												<xsl:value-of select="$truncatedTitle"/>
											</ogc:Literal>
										</ogc:PropertyIsLike>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="count($response//csw:SearchResults/csw:SummaryRecord) lt 1">
						<ctl:message>[FAILURE] At least one csw:SummaryRecord elements expected in
							response.</ctl:message>
						<ctl:fail/>
					</xsl:if>
					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:if
							test="starts-with(dc:title,substring($title.1,1,string-length($title.1)-1)) != true()">
							<ctl:message>[FAILURE] Unexpected record is included (dc:title does not
								match expression <xsl:value-of select="$truncatedTitle"
								/>)</ctl:message>
							<ctl:fail/>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc11.2">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having a
			PropertyIsLike predicate must include matching record representations. </assertion>
		<comment>Pass if the csw:SearchResults element contains only csw:SummaryRecord instances
			having a dc:date value satisfying a dynamic expression. This expression is obtained by
			reading the date of the first record that has a date and sobstituting the last digit of
			the year with the symbol of a single char (?) and the day with the symbol of
			wildcard</comment>
		<code>
			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:date</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsGreaterThanOrEqualTo>
											<ogc:PropertyName>dc:date</ogc:PropertyName>
											<ogc:Literal>0000-00-00</ogc:Literal>
										</ogc:PropertyIsGreaterThanOrEqualTo>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<xsl:variable name="id.1">
				<xsl:value-of select="$response0//csw:SearchResults/*[1]/dc:identifier"/>
			</xsl:variable>
			<xsl:variable name="year"
				select="substring-before($response0//csw:SearchResults/*[1]/dc:date,'-')"/>
			<xsl:variable name="month"
				select="substring-before(substring-after($response0//csw:SearchResults/*[1]/dc:date,'-'),'-')"/>
			<!--<xsl:variable name="day" select="string-after(string-after($response0//csw:SearchResults/*[1]/dc:date,'-'),'-')"/>-->
			<xsl:variable name="wildDate"
				select="concat(substring($year,1,string-length($year)-1),'?-',$month,'-*')"/>
			<ctl:message select="$response0"/>
			<ctl:message>Titolo letto:</ctl:message>
			<ctl:message select="$id.1"/>
			<ctl:message select="$wildDate"/>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>full</csw:ElementSetName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsLike wildCard="*" singleChar="?"
											escapeChar="\">
											<ogc:PropertyName>dc:date</ogc:PropertyName>
											<ogc:Literal>
												<xsl:value-of select="$wildDate"/>
											</ogc:Literal>
										</ogc:PropertyIsLike>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:choose>
						<xsl:when test="count($response//csw:SearchResults/csw:Record) lt 1">
							<ctl:message>[FAILURE] AT least one csw:Record element expected in
								response.</ctl:message>
							<ctl:fail/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:variable name="checkDate"
								select="concat(substring($year,1,string-length($year)-1),'.-',$month,'-*')"/>
							<xsl:for-each select="$response//csw:SearchResults/*">
								<xsl:if test="matches(dc:date,$checkDate) != true()">
									<ctl:message>[FAILURE] Unexpected record is included
											(<xsl:value-of select="dc:date"/> value does not match
										expression <xsl:value-of select="$checkDate"
										/>)</ctl:message>
									<ctl:fail/>
								</xsl:if>
							</xsl:for-each>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc12.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having a
			PropertyIsLessThanOrEqualTo predicate must include matching record representations. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains at least two csw:Record elements having
			dc:identifier value less or equal than an identifier selected dynamically from a list of
			identifier oredered by id</comment>
		<code>
			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<ogc:SortBy>
									<ogc:SortProperty>
										<ogc:PropertyName>dc:identifier</ogc:PropertyName>
										<ogc:SortOrder>ASC</ogc:SortOrder>
									</ogc:SortProperty>
								</ogc:SortBy>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<xsl:variable name="matches.1"
				select="$response0//csw:SearchResults/@numberOfRecordsReturned"/>
			<xsl:variable name="middle" select="floor($matches.1 div 2)"/>
			<ctl:message>risposta0:</ctl:message>
			<ctl:message select="$response0"/>
			<ctl:message select="$middle"/>
			<xsl:variable name="id" select="$response0//csw:SearchResults/*[$middle]/dc:identifier"/>
			<ctl:message>selected id</ctl:message>
			<ctl:message select="$id"/>

			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:type</csw:ElementName>
								<csw:ElementName>dc:date</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsLessThanOrEqualTo>
											<ogc:PropertyName>dc:identifier</ogc:PropertyName>
											<ogc:Literal>
												<xsl:value-of select="$id"/>
											</ogc:Literal>
										</ogc:PropertyIsLessThanOrEqualTo>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="count($response//csw:SearchResults/csw:Record) lt 1">
						<ctl:message>[FAILURE] AT least one csw:Record element expected in
							response.</ctl:message>
						<ctl:fail/>
					</xsl:if>
					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:if test="dc:identifier gt $id">
							<ctl:message>[FAILURE] Included Record with identifier greater than
									<xsl:value-of select="$id"/> (<xsl:value-of
									select="dc:identifier"/>)</ctl:message>
							<ctl:fail/>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc13.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having a
			PropertyIsGreaterThanOrEqualTo predicate must include matching record representations. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains at least two csw:Record elements having
			dc:identifier value greater than an identifier selected dynamically from a list of
			identifier oredered by id</comment>
		<code>
			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<ogc:SortBy>
									<ogc:SortProperty>
										<ogc:PropertyName>dc:identifier</ogc:PropertyName>
										<ogc:SortOrder>ASC</ogc:SortOrder>
									</ogc:SortProperty>
								</ogc:SortBy>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<xsl:variable name="matches.1"
				select="$response0//csw:SearchResults/@numberOfRecordsReturned"/>
			<xsl:variable name="middle" select="floor($matches.1 div 2)"/>
			<ctl:message>risposta0:</ctl:message>
			<ctl:message select="$response0"/>
			<ctl:message select="$middle"/>
			<xsl:variable name="id" select="$response0//csw:SearchResults/*[$middle]/dc:identifier"/>
			<ctl:message>selected id</ctl:message>
			<ctl:message select="$id"/>

			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:type</csw:ElementName>
								<csw:ElementName>dc:date</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsGreaterThanOrEqualTo>
											<ogc:PropertyName>dc:identifier</ogc:PropertyName>
											<ogc:Literal>
												<xsl:value-of select="$id"/>
											</ogc:Literal>
										</ogc:PropertyIsGreaterThanOrEqualTo>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="count($response//csw:SearchResults/csw:Record) lt 1">
						<ctl:message>[FAILURE] AT least one csw:Record element expected in
							response.</ctl:message>
						<ctl:fail/>
					</xsl:if>
					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:if test="dc:identifier lt $id">
							<ctl:message>[FAILURE] Included record with itentifier less than
									<xsl:value-of select="$id"/> (<xsl:value-of
									select="dc:identifier"/>)</ctl:message>
							<ctl:fail/>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc14.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having a Not
			logical predicate must include only matching record representations. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains maximum 20 csw:SummaryRecord elements having
			identifiers that do not start with the string equal to the identifier of a record
			selected dinamically and truncated at its half and concatenated with wildcard symbol (3)
			the number of records returned by the test summed with the number returned by the
			complement of the test must be qual to the number of records in the DB</comment>
		<code>
			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:title</csw:ElementName>
								<ogc:SortBy>
									<ogc:SortProperty>
										<ogc:PropertyName>dc:identifier</ogc:PropertyName>
										<ogc:SortOrder>ASC</ogc:SortOrder>
									</ogc:SortProperty>
								</ogc:SortBy>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<xsl:variable name="NumberOfRecordInDB"
				select="xsd:integer($response0//csw:SearchResults/@numberOfRecordsMatched)"/>
			<xsl:variable name="id.1">
				<xsl:value-of select="$response0//csw:SearchResults/*[1]/dc:identifier"/>
			</xsl:variable>
			<xsl:variable name="middleString" select="floor(string-length($id.1) div 2)"/>
			<xsl:variable name="truncatedId"
				select="concat(substring($id.1,1,xsd:integer($middleString)),'*')"/>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results"
							maxRecords="20">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>summary</csw:ElementSetName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:Not>
											<ogc:PropertyIsLike wildCard="*" singleChar="?"
												escapeChar="\">
												<ogc:PropertyName>dc:identifier</ogc:PropertyName>
												<ogc:Literal>
												<xsl:value-of select="$truncatedId"/>
												</ogc:Literal>
											</ogc:PropertyIsLike>
										</ogc:Not>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:variable name="summaryRecCount"
						select="count($response//csw:SearchResults/csw:SummaryRecord)"/>
					<xsl:if test="($summaryRecCount &gt; 20)">
						<ctl:message>[FAILURE] maximum 20 csw:SummaryRecord elements expected in
							response (<xsl:value-of select="$summaryRecCount"/>
							included)</ctl:message>
						<ctl:fail/>
					</xsl:if>
					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:if test="starts-with(dc:identifier,$truncatedId) = true()">
							<ctl:message>[FAILURE] Unexpected record is included (dc:identifier
								starts with <xsl:value-of select="$truncatedId"/>)</ctl:message>
							<ctl:fail/>
						</xsl:if>
					</xsl:for-each>
					<xsl:variable name="responseVerify">
						<request>
							<url>
								<xsl:value-of select="$csw.GetRecords.post.url"/>
							</url>
							<method>POST</method>
							<body>
								<csw:GetRecords service="CSW" version="2.0.2" resultType="results"
									maxRecords="20">
									<csw:Query typeNames="csw:Record">
										<csw:ElementSetName>summary</csw:ElementSetName>
										<csw:Constraint version="1.1.0">
											<ogc:Filter>
												<ogc:PropertyIsLike wildCard="*" singleChar="?"
												escapeChar="\">
												<ogc:PropertyName>dc:identifier</ogc:PropertyName>
												<ogc:Literal>
												<xsl:value-of select="$truncatedId"/>
												</ogc:Literal>
												</ogc:PropertyIsLike>
											</ogc:Filter>
										</csw:Constraint>
									</csw:Query>
								</csw:GetRecords>
							</body>
							<p:XMLValidatingParser.CSW/>
						</request>
					</xsl:variable>
					<xsl:variable name="totalReturned"
						select="xsd:integer($responseVerify//csw:SearchResults/@numberOfRecordsMatched) + xsd:integer($response//csw:SearchResults/@numberOfRecordsMatched)"/>
					<ctl:message>Record totali: <xsl:value-of select="$NumberOfRecordInDB"
						/></ctl:message>
					<ctl:message>Record tornati: <xsl:value-of select="$totalReturned"
						/></ctl:message>
					<xsl:if test="not($totalReturned eq $NumberOfRecordInDB)">
						<ctl:message>[FAILURE] Returned records dosen't match expected
							number</ctl:message>
						<ctl:fail/>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc14.2">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having a Not
			logical predicate must include only matching record representations. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains 11-20 csw:Record elements having extents that
			are either disjoint from the given bounding box or have no ows:BoundingBox child
			element.</comment>
		<code>
			<xsl:variable name="response0">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results"
							maxRecords="20">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>ows:BoundingBox</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:BBOX>
											<ogc:PropertyName>ows:BoundingBox</ogc:PropertyName>
											<gml:Envelope srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
												<gml:lowerCorner>-180.0 -90.0</gml:lowerCorner>
												<gml:upperCorner>180.0 90.0</gml:upperCorner>
											</gml:Envelope>
										</ogc:BBOX>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>
			<xsl:variable name="NumberOfRecordInDB"
				select="xsd:integer($response0//csw:SearchResults/@numberOfRecordsMatched)"/>
			<ctl:message select="$response0"/>
			<xsl:variable name="matches.1"
				select="$response0//csw:SearchResults/@numberOfRecordsReturned"/>
			<xsl:variable name="middle" select="ceiling($matches.1 div 2)"/>
			<xsl:variable name="id" select="$response0//csw:SearchResults/*[$middle]/dc:identifier"/>
			<xsl:variable name="boundingBoxLower"
				select="$response0//csw:SearchResults/*[$middle]/ows:BoundingBox/ows:LowerCorner"/>
			<xsl:variable name="boundingBoxUpper"
				select="$response0//csw:SearchResults/*[$middle]/ows:BoundingBox/ows:UpperCorner"/>
			<ctl:message>selected id</ctl:message>
			<ctl:message select="$id"/>
			<ctl:message select="$boundingBoxLower"/>
			<ctl:message select="$boundingBoxUpper"/>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results"
							maxRecords="20">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>ows:BoundingBox</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:And>
											<ogc:BBOX>
												<ogc:PropertyName>ows:BoundingBox</ogc:PropertyName>
												<gml:Envelope
												srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
												<gml:lowerCorner>-180.0 -90.0</gml:lowerCorner>
												<gml:upperCorner>180.0 90.0</gml:upperCorner>
												</gml:Envelope>
											</ogc:BBOX>
											<ogc:Not>
												<ogc:BBOX>
												<ogc:PropertyName>ows:BoundingBox</ogc:PropertyName>
												<gml:Envelope
												srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
												<gml:lowerCorner>
												<xsl:value-of select="$boundingBoxLower"/>
												</gml:lowerCorner>
												<gml:upperCorner>
												<xsl:value-of select="$boundingBoxUpper"/>
												</gml:upperCorner>
												</gml:Envelope>
												</ogc:BBOX>
											</ogc:Not>
										</ogc:And>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>
			<ctl:message>Risposta 2</ctl:message>
			<ctl:message select="$response"/>
			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:variable name="recordCount"
						select="count($response//csw:SearchResults/csw:Record)"/>
					<xsl:if test="$recordCount gt 20">
						<ctl:message>[FAILURE] maximum 20 csw:Record elements expected in response
								(<xsl:value-of select="$recordCount"/> included)</ctl:message>
						<ctl:fail/>
					</xsl:if>
					<xsl:variable name="env">
						<gml:Envelope srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
							<gml:lowerCorner>
								<xsl:value-of select="$boundingBoxLower"/>
							</gml:lowerCorner>
							<gml:upperCorner>
								<xsl:value-of select="$boundingBoxUpper"/>
							</gml:upperCorner>
						</gml:Envelope>
					</xsl:variable>
					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:if test="ows:BoundingBox">
							<xsl:if test="csw:disjoint-envelopes($env,ows:BoundingBox) != 1">
								<ctl:message>[FAILURE] Envelopes intersect (<xsl:value-of
										select="dc:identifier"/>)</ctl:message>
								<ctl:fail/>
							</xsl:if>
						</xsl:if>
					</xsl:for-each>
					<xsl:variable name="responseVerify">
						<request>
							<url>
								<xsl:value-of select="$csw.GetRecords.post.url"/>
							</url>
							<method>POST</method>
							<body>
								<csw:GetRecords service="CSW" version="2.0.2" resultType="results"
									maxRecords="20">
									<csw:Query typeNames="csw:Record">
										<csw:ElementSetName>summary</csw:ElementSetName>
										<csw:Constraint version="1.1.0">
											<ogc:Filter>
												<ogc:BBOX>
												<ogc:PropertyName>ows:BoundingBox</ogc:PropertyName>
												<gml:Envelope
												srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
												<gml:lowerCorner>
												<xsl:value-of select="$boundingBoxLower"/>
												</gml:lowerCorner>
												<gml:upperCorner>
												<xsl:value-of select="$boundingBoxUpper"/>
												</gml:upperCorner>
												</gml:Envelope>
												</ogc:BBOX>
											</ogc:Filter>
										</csw:Constraint>
									</csw:Query>
								</csw:GetRecords>
							</body>
							<p:XMLValidatingParser.CSW/>
						</request>
					</xsl:variable>
					<xsl:variable name="totalReturned"
						select="xsd:integer($responseVerify//csw:SearchResults/@numberOfRecordsMatched) + xsd:integer($response//csw:SearchResults/@numberOfRecordsMatched)"/>
					<ctl:message>Record totali: <xsl:value-of select="$NumberOfRecordInDB"
						/></ctl:message>
					<ctl:message>Record tornati: <xsl:value-of select="$totalReturned"
						/></ctl:message>
					<xsl:if test="not($totalReturned eq $NumberOfRecordInDB)">
						<ctl:message>[FAILURE] Returned records dosen't match expected
							number</ctl:message>
						<ctl:fail/>
					</xsl:if>

				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc15.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an invalid filter expression
			must include an exception report. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is a valid
			ows:ExceptionReport; (2) the reported exceptionCode is "NoApplicableCode".</comment>
		<code>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="hits">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>brief</csw:ElementSetName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter xmlns:ogc="http://www.opengis.net/foo">
										<ogc:PropertyIsEqualTo>
											<ogc:PropertyName>dc:title</ogc:PropertyName>
											<ogc:Literal>Maecenas enim</ogc:Literal>
										</ogc:PropertyIsEqualTo>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.OWS/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:call-test name="ctl:SchematronValidatingParser">
						<ctl:with-param name="doc" select="$response"/>
						<ctl:with-param name="schema"
							>sch/ows/1.0.0/ExceptionReport.sch</ctl:with-param>
						<ctl:with-param name="phase">NoApplicableCodePhase</ctl:with-param>
					</ctl:call-test>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc16.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having the Or
			logical predicate must include only matching record representations. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains 1-10 csw:SummaryRecord elements that have
			dc:type OR dc:title choosen dynamically</comment>
		<code>
			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:type</csw:ElementName>
								<csw:ElementName>dc:title</csw:ElementName>
								<ogc:SortBy>
									<ogc:SortProperty>
										<ogc:PropertyName>dc:identifier</ogc:PropertyName>
										<ogc:SortOrder>DESC</ogc:SortOrder>
									</ogc:SortProperty>
								</ogc:SortBy>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsGreaterThan>
											<ogc:PropertyName>dc:type</ogc:PropertyName>
											<ogc:Literal>' '</ogc:Literal>
										</ogc:PropertyIsGreaterThan>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<xsl:variable name="matches.1"
				select="$response0//csw:SearchResults/@numberOfRecordsReturned"/>
			<xsl:variable name="middle" select="floor($matches.1 div 2)"/>
			<xsl:variable name="title" select="$response0//csw:SearchResults/*[$middle]/dc:title"/>
			<xsl:variable name="type"
				select="$response0//csw:SearchResults/*[xsd:integer($middle)+1]/dc:type"/>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>summary</csw:ElementSetName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:Or>
											<ogc:PropertyIsLike wildCard="*" singleChar="?"
												escapeChar="\">
												<ogc:PropertyName>dc:title</ogc:PropertyName>
												<ogc:Literal>
												<xsl:value-of select="$title"/>
												</ogc:Literal>
											</ogc:PropertyIsLike>
											<ogc:PropertyIsEqualTo>
												<ogc:PropertyName>dc:type</ogc:PropertyName>
												<ogc:Literal>
												<xsl:value-of select="$type"/>
												</ogc:Literal>
											</ogc:PropertyIsEqualTo>
										</ogc:Or>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:call-test name="ctl:SchematronValidatingParser">
						<ctl:with-param name="doc" select="$response"/>
						<ctl:with-param name="schema">sch/csw/2.0.2/GetRecords.sch</ctl:with-param>
						<ctl:with-param name="phase">TypeFormatElementsPhase</ctl:with-param>
					</ctl:call-test>
					<xsl:for-each select="$response//csw:SummaryRecord">
						<xsl:if test="not(dc:title or dc:type)">
							<ctl:message>[FAILURE] csw:Record is missing an expected property:
								dc:title or dc:type</ctl:message>
							<ctl:fail/>
						</xsl:if>
						<xsl:if test="(dc:type != $type) and (dc:title != $title)">
							<ctl:message>[FAILURE] dc:type != <xsl:value-of select="$type"/> AND
								dc:title != <xsl:value-of select="$title"/>)</ctl:message>
							<ctl:fail/>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc16.2">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having the Or
			logical predicate must include only matching record representations. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains 1-10 csw:Record child elements that have a
			matching extent OR has a type equal to one choosen dynamically.</comment>
		<code>
			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:type</csw:ElementName>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<xsl:variable name="type" select="$response0//csw:SearchResults/*[1]/dc:type"/>
			<xsl:variable name="response1">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results"
							maxRecords="20">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>ows:BoundingBox</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:BBOX>
											<ogc:PropertyName>ows:BoundingBox</ogc:PropertyName>
											<gml:Envelope srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
												<gml:lowerCorner>-180.0 -90.0</gml:lowerCorner>
												<gml:upperCorner>180.0 90.0</gml:upperCorner>
											</gml:Envelope>
										</ogc:BBOX>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>
			<xsl:variable name="matches.1"
				select="$response1//csw:SearchResults/@numberOfRecordsReturned"/>
			<xsl:variable name="middle" select="ceiling($matches.1 div 2)"/>
			<xsl:variable name="boundingBoxLower"
				select="$response1//csw:SearchResults/*[$middle]/ows:BoundingBox/ows:LowerCorner"/>
			<xsl:variable name="boundingBoxUpper"
				select="$response1//csw:SearchResults/*[$middle]/ows:BoundingBox/ows:UpperCorner"/>
			<ctl:message select="$response1//csw:SearchResults/*[$middle]/ows:BoundingBox"/>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:title</csw:ElementName>
								<csw:ElementName>ows:BoundingBox</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:Or>
											<ogc:BBOX>
												<ogc:PropertyName>ows:BoundingBox</ogc:PropertyName>
												<gml:Envelope
												srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
												<gml:lowerCorner>
												<xsl:value-of select="$boundingBoxLower"/>
												</gml:lowerCorner>
												<gml:upperCorner>
												<xsl:value-of select="$boundingBoxUpper"/>
												</gml:upperCorner>
												</gml:Envelope>
											</ogc:BBOX>
											<ogc:PropertyIsGreaterThan>
												<ogc:PropertyName>dc:type</ogc:PropertyName>
												<ogc:Literal>
												<xsl:value-of select="$type"/>
												</ogc:Literal>
											</ogc:PropertyIsGreaterThan>
										</ogc:Or>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>
			<ctl:message>Risposta</ctl:message>
			<ctl:message select="$response"/>
			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:variable name="env">
						<gml:Envelope srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
							<gml:lowerCorner>
								<xsl:value-of select="$boundingBoxLower"/>
							</gml:lowerCorner>
							<gml:upperCorner>
								<xsl:value-of select="$boundingBoxUpper"/>
							</gml:upperCorner>
						</gml:Envelope>
					</xsl:variable>
					<xsl:for-each select="$response//csw:Record">
						<xsl:if
							test="(dc:title le $type) and (csw:disjoint-envelopes($env,ows:BoundingBox) != 0)">
							<ctl:message>[FAILURE] Record with title less or equal than
									<xsl:value-of select="$type"/> AND envelopes do not intersect
									(<xsl:value-of select="dc:identifier"/>)</ctl:message>
							<ctl:fail/>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc17.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having the And
			logical predicate must include only matching record representations. </assertion>
		<comment> Pass if the csw:SearchResults element contains 1-10 csw:SummaryRecord elements
			that have dc:date AND dc:type related to a the given record. </comment>
		<code>

			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:type</csw:ElementName>
								<csw:ElementName>dc:date</csw:ElementName>
								<ogc:SortBy>
									<ogc:SortProperty>
										<ogc:PropertyName>dc:identifier</ogc:PropertyName>
										<ogc:SortOrder>DESC</ogc:SortOrder>
									</ogc:SortProperty>
								</ogc:SortBy>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsGreaterThanOrEqualTo>
											<ogc:PropertyName>dc:date</ogc:PropertyName>
											<ogc:Literal>0000-00-00</ogc:Literal>
										</ogc:PropertyIsGreaterThanOrEqualTo>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<ctl:message>Risposta</ctl:message>
			<ctl:message select="$response0"/>
			<xsl:variable name="matches.1"
				select="$response0//csw:SearchResults/@numberOfRecordsReturned"/>
			<ctl:message select="$matches.1"/>
			<xsl:variable name="middle" select="ceiling($matches.1 div 2)"/>
			<xsl:variable name="id" select="$response0//csw:SearchResults/*[$middle]/dc:identifier"/>
			<xsl:variable name="type" select="$response0//csw:SearchResults/*[$middle]/dc:type"/>
			<xsl:variable name="date" select="$response0//csw:SearchResults/*[$middle]/dc:date"/>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>summary</csw:ElementSetName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:And>
											<ogc:PropertyIsLike wildCard="*" singleChar="?"
												escapeChar="\">
												<ogc:PropertyName>dc:type</ogc:PropertyName>
												<ogc:Literal>
												<xsl:value-of select="$type"/>
												</ogc:Literal>
											</ogc:PropertyIsLike>
											<ogc:PropertyIsEqualTo>
												<ogc:PropertyName>dc:date</ogc:PropertyName>
												<ogc:Literal>
												<xsl:value-of select="$date"/>
												</ogc:Literal>
											</ogc:PropertyIsEqualTo>
										</ogc:And>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:variable name="recordCount"
						select="count($response//csw:SearchResults/csw:SummaryRecord)"/>
					<xsl:if test="($recordCount lt 1) or ($recordCount gt 10)">
						<ctl:message>[FAILURE] 1-10 csw:SummaryRecord elements expected in response
								(<xsl:value-of select="$recordCount"/> included)</ctl:message>
						<ctl:fail/>
					</xsl:if>
					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:if test="(dc:date != $date) and (dc:type != $type)">
							<ctl:message>[FAILURE] Record has invalid type or data (<xsl:value-of
									select="dc:identifier"/>)</ctl:message>
							<ctl:fail/>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc17.2">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having the And
			logical predicate must include only matching record representations. </assertion>
		<comment> Pass if the csw:SearchResults element contains 1-10 csw:Record elements that have
			envelopes intersecting the given bounding box AND were dated after a given date. </comment>
		<code>

			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>ows:BoundingBox</csw:ElementName>
								<csw:ElementName>dc:date</csw:ElementName>
								<ogc:SortBy>
									<ogc:SortProperty>
										<ogc:PropertyName>dc:identifier</ogc:PropertyName>
										<ogc:SortOrder>DESC</ogc:SortOrder>
									</ogc:SortProperty>
								</ogc:SortBy>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:And>
											<ogc:PropertyIsGreaterThanOrEqualTo>
												<ogc:PropertyName>dc:date</ogc:PropertyName>
												<ogc:Literal>0000-00-00</ogc:Literal>
											</ogc:PropertyIsGreaterThanOrEqualTo>
											<ogc:BBOX>
												<ogc:PropertyName>ows:BoundingBox</ogc:PropertyName>
												<gml:Envelope
												srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
												<gml:lowerCorner>-180.0 -90.0</gml:lowerCorner>
												<gml:upperCorner>180.0 90.0</gml:upperCorner>
												</gml:Envelope>
											</ogc:BBOX>
										</ogc:And>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<ctl:message>Risposta0</ctl:message>
			<ctl:message select="$response0"/>
			<xsl:variable name="matches.1"
				select="$response0//csw:SearchResults/@numberOfRecordsReturned"/>
			<ctl:message select="$matches.1"/>
			<xsl:variable name="middle" select="ceiling($matches.1 div 2)"/>
			<xsl:variable name="id" select="$response0//csw:SearchResults/*[$middle]/dc:identifier"/>
			<xsl:variable name="date" select="$response0//csw:SearchResults/*[$middle]/dc:date"/>
			<xsl:variable name="boundingBoxLower"
				select="$response0//csw:SearchResults/*[$middle]/ows:BoundingBox/ows:LowerCorner"/>
			<xsl:variable name="boundingBoxUpper"
				select="$response0//csw:SearchResults/*[$middle]/ows:BoundingBox/ows:UpperCorner"/>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:date</csw:ElementName>
								<csw:ElementName>ows:BoundingBox</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:And>
											<ogc:BBOX>
												<ogc:PropertyName>ows:BoundingBox</ogc:PropertyName>
												<gml:Envelope
												srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
												<gml:lowerCorner>
												<xsl:value-of select="$boundingBoxLower"/>
												</gml:lowerCorner>
												<gml:upperCorner>
												<xsl:value-of select="$boundingBoxUpper"/>
												</gml:upperCorner>
												</gml:Envelope>
											</ogc:BBOX>
											<ogc:PropertyIsGreaterThanOrEqualTo>
												<ogc:PropertyName>dc:date</ogc:PropertyName>
												<ogc:Literal>
												<xsl:value-of select="xsd:date($date)"/>
												</ogc:Literal>
											</ogc:PropertyIsGreaterThanOrEqualTo>
										</ogc:And>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>
			<ctl:message>Risposta1</ctl:message>
			<ctl:message select="$response"/>
			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:variable name="recordCount"
						select="count($response//csw:SearchResults/csw:Record)"/>
					<xsl:if test="($recordCount &lt; 1) or ($recordCount &gt; 10)">
						<ctl:message>[FAILURE] 1-10 csw:Record elements expected in response
								(<xsl:value-of select="$recordCount"/> included)</ctl:message>
						<ctl:fail/>
					</xsl:if>
					<xsl:variable name="env">
						<gml:Envelope srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
							<gml:lowerCorner>
								<xsl:value-of select="$boundingBoxLower"/>
							</gml:lowerCorner>
							<gml:upperCorner>
								<xsl:value-of select="$boundingBoxUpper"/>
							</gml:upperCorner>
						</gml:Envelope>
					</xsl:variable>
					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:choose>
							<xsl:when test="contains(dc:date, 'T')">
								<!-- date is a top-open interval of exactly one day in length, up to but not including 24:00:00 -->
								<xsl:if
									test="xsd:date(concat(substring-before(dc:date,'T'),'Z')) lt xsd:date($date)">
									<ctl:message>[FAILURE] dc:date value occurs at or before
											<xsl:value-of select="$date"/>(<xsl:value-of
											select="dc:identifier"/>)</ctl:message>
									<ctl:fail/>
								</xsl:if>
							</xsl:when>
							<xsl:otherwise>
								<xsl:if test="xsd:date(dc:date) lt xsd:date($date)">
									<ctl:message>[FAILURE] dc:date value on or before <xsl:value-of
											select="$date"/> (<xsl:value-of select="dc:identifier"
										/>)</ctl:message>
									<ctl:fail/>
								</xsl:if>
							</xsl:otherwise>
						</xsl:choose>
						<xsl:if test="csw:disjoint-envelopes($env,ows:BoundingBox) != 0">
							<ctl:message>[FAILURE] Envelopes do NOT intersect (<xsl:value-of
									select="dc:identifier"/>)</ctl:message>
							<ctl:fail/>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc18.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having the And
			logical predicate must include the specified view of records that satisfy all
			constraints. </assertion>
		<code>
			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>ows:BoundingBox</csw:ElementName>
								<csw:ElementName>dc:type</csw:ElementName>
								<ogc:SortBy>
									<ogc:SortProperty>
										<ogc:PropertyName>dc:identifier</ogc:PropertyName>
										<ogc:SortOrder>DESC</ogc:SortOrder>
									</ogc:SortProperty>
								</ogc:SortBy>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:BBOX>
											<ogc:PropertyName>ows:BoundingBox</ogc:PropertyName>
											<gml:Envelope srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
												<gml:lowerCorner>-180.0 -90.0</gml:lowerCorner>
												<gml:upperCorner>180.0 90.0</gml:upperCorner>
											</gml:Envelope>
										</ogc:BBOX>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<ctl:message>Risposta0</ctl:message>
			<ctl:message select="$response0"/>
			<xsl:variable name="matches.1"
				select="$response0//csw:SearchResults/@numberOfRecordsReturned"/>
			<ctl:message select="$matches.1"/>
			<xsl:variable name="middle" select="ceiling($matches.1 div 2)"/>
			<xsl:variable name="type"
				select="$response0//csw:SearchResults/*[xsd:integer($middle)-1]/dc:type"/>
			<xsl:variable name="boundingBoxLower"
				select="$response0//csw:SearchResults/*[$middle]/ows:BoundingBox/ows:LowerCorner"/>
			<xsl:variable name="boundingBoxUpper"
				select="$response0//csw:SearchResults/*[$middle]/ows:BoundingBox/ows:UpperCorner"/>
			<ctl:message select="$response0//csw:SearchResults/*[$middle]"/>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:type</csw:ElementName>
								<csw:ElementName>ows:BoundingBox</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:And>
											<ogc:Not>
												<ogc:BBOX>
												<ogc:PropertyName>ows:BoundingBox</ogc:PropertyName>
												<gml:Envelope
												srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
												<gml:lowerCorner>
												<xsl:value-of select="$boundingBoxLower"/>
												</gml:lowerCorner>
												<gml:upperCorner>
												<xsl:value-of select="$boundingBoxUpper"/>
												</gml:upperCorner>
												</gml:Envelope>
												</ogc:BBOX>
											</ogc:Not>
											<ogc:PropertyIsEqualTo matchCase="false">
												<ogc:PropertyName>dc:type</ogc:PropertyName>
												<ogc:Literal>
												<xsl:value-of select="$type"/>
												</ogc:Literal>
											</ogc:PropertyIsEqualTo>
										</ogc:And>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>
			<ctl:message>Risposta1</ctl:message>
			<ctl:message select="$response"/>
			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:variable name="recordCount"
						select="count($response//csw:SearchResults/csw:Record)"/>
					<xsl:if test="($recordCount &gt; 10)">
						<ctl:message>[FAILURE] max 10 csw:Record elements expected in response
								(<xsl:value-of select="$recordCount"/> included)</ctl:message>
						<ctl:fail/>
					</xsl:if>
					<xsl:variable name="env">
						<gml:Envelope srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
							<gml:lowerCorner>
								<xsl:value-of select="$boundingBoxLower"/>
							</gml:lowerCorner>
							<gml:upperCorner>
								<xsl:value-of select="$boundingBoxUpper"/>
							</gml:upperCorner>
						</gml:Envelope>
					</xsl:variable>
					<xsl:for-each select="$response//csw:SearchResults/*">
						<xsl:if test="compare(lower-case(dc:type), lower-case($type)) != 0">
							<ctl:message>[FAILURE] Unexpected record having dc:type not matching
									<xsl:value-of select="$type"/> (case-insensitive) -
									(<xsl:value-of select="dc:identifier"/>)</ctl:message>
							<ctl:fail/>
						</xsl:if>
						<xsl:if test="ows:BoundingBox">
							<xsl:if test="csw:disjoint-envelopes($env,ows:BoundingBox) != 1">
								<ctl:message>[FAILURE] Envelopes intersect (<xsl:value-of
										select="dc:identifier"/>)</ctl:message>
								<ctl:fail/>
							</xsl:if>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc19.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes an ogc:Filter having a
			PropertyIsLike predicate must include the specified view of all matching records. If a
			PropertyName value is not supplied, the predicate is evaluated against all applicable
			record properties. </assertion>
		<code>
			<xsl:variable name="response0">
				<ctl:request>
					<ctl:url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</ctl:url>
					<ctl:method>POST</ctl:method>
					<ctl:body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>dc:type</csw:ElementName>
								<csw:ElementName>dc:title</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsGreaterThan>
											<ogc:PropertyName>dc:title</ogc:PropertyName>
											<ogc:Literal>' '</ogc:Literal>
										</ogc:PropertyIsGreaterThan>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</ctl:body>
					<p:XMLValidatingParser.CSW/>
				</ctl:request>
			</xsl:variable>
			<ctl:message>Risposta0</ctl:message>
			<ctl:message select="$response0"/>
			<xsl:variable name="matches.1"
				select="$response0//csw:SearchResults/@numberOfRecordsReturned"/>
			<ctl:message select="$matches.1"/>
			<xsl:variable name="middle" select="ceiling($matches.1 div 2)"/>
			<xsl:variable name="id" select="$response0//csw:SearchResults/*[$middle]/dc:identifier"/>
			<xsl:variable name="title" select="$response0//csw:SearchResults/*[$middle]/dc:title"/>
			<xsl:variable name="truncatedTitle"
				select="concat('*',substring($title,2,xsd:integer(string-length($title))-2),'*')"/>
			<ctl:message select="$truncatedTitle"/>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>full</csw:ElementSetName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsLike wildCard="*" singleChar="."
											escapeChar="\">
											<ogc:PropertyName>csw:AnyText</ogc:PropertyName>
											<ogc:Literal>
												<xsl:value-of select="$truncatedTitle"/>
											</ogc:Literal>
										</ogc:PropertyIsLike>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="count($response//csw:SearchResults/csw:Record) lt 1">
						<ctl:message>[FAILURE] Expected at least 1 csw:Record elements with property
							values matching the expression "*lorem*".</ctl:message>
						<ctl:fail/>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc20.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The csw:SummaryRecord view type cannot be queried. The response shall include an
			exception having @exceptionCode = "InvalidParameterValue" [10.2.5.3.3]. </assertion>
		<code>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:SummaryRecord">
								<csw:ElementSetName>summary</csw:ElementSetName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsLike wildCard="*" singleChar="."
											escapeChar="\">
											<ogc:PropertyName>/dc:title</ogc:PropertyName>
											<ogc:Literal>*wololoo*</ogc:Literal>
										</ogc:PropertyIsLike>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.OWS/>
				</request>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:call-test name="ctl:SchematronValidatingParser">
						<ctl:with-param name="doc" select="$response"/>
						<ctl:with-param name="schema"
							>sch/ows/1.0.0/ExceptionReport.sch</ctl:with-param>
						<ctl:with-param name="phase">InvalidParameterValuePhase</ctl:with-param>
					</ctl:call-test>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc21.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The csw:BriefRecord view type cannot be queried. The response shall include an
			exception having @exceptionCode = "InvalidParameterValue" [10.2.5.3.4]. </assertion>
		<code>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results">
							<csw:Query typeNames="csw:BriefRecord">
								<csw:ElementSetName>brief</csw:ElementSetName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsLike wildCard="*" singleChar="."
											escapeChar="\">
											<ogc:PropertyName>/dc:title</ogc:PropertyName>
											<ogc:Literal>*wololoo*</ogc:Literal>
										</ogc:PropertyIsLike>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.OWS/>
				</request>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:call-test name="ctl:SchematronValidatingParser">
						<ctl:with-param name="doc" select="$response"/>
						<ctl:with-param name="schema"
							>sch/ows/1.0.0/ExceptionReport.sch</ctl:with-param>
						<ctl:with-param name="phase">InvalidParameterValuePhase</ctl:with-param>
					</ctl:call-test>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc22.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that includes the startPosition parameter
			must include the corresponding slice of the result set. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element contains exactly 5 csw:SummaryRecord child elements;
			(3) csw:SearchResults/@nextRecord = 8.</comment>
		<code>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results"
							startPosition="3" maxRecords="5">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>summary</csw:ElementSetName>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:variable name="nSummaryRecord"
						select="count($response//csw:SearchResults/csw:SummaryRecord)"/>
					<xsl:if test="nSummaryRecord != 5">
						<ctl:message>[FAILURE] 5 csw:SummaryRecord elements expected (<xsl:value-of
								select="$nSummaryRecord"/> returned).</ctl:message>
						<ctl:fail/>
					</xsl:if>
					<xsl:if test="$response//csw:SearchResults/@numberOfRecordsReturned != 5">
						<ctl:message>[FAILURE] @numberOfRecordsReturned != 5.</ctl:message>
						<ctl:fail/>
					</xsl:if>
					<xsl:if test="$response//csw:SearchResults/@nextRecord != 8">
						<ctl:message>[FAILURE] @nextRecord != 8.</ctl:message>
						<ctl:fail/>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc23.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that specifies maxRecords="0" must not
			include any results. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is schema valid;
			(2) the csw:SearchResults element is empty; (3)
			csw:SearchResults/@numberOfRecordsMatched &gt; 0; (4) csw:SearchResults/@nextRecord = 1 </comment>
		<code>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results"
							maxRecords="0">
							<csw:Query typeNames="csw:Record">
								<csw:ElementName>dc:identifier</csw:ElementName>
								<csw:ElementName>ows:BoundingBox</csw:ElementName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:BBOX>
											<ogc:PropertyName>ows:BoundingBox</ogc:PropertyName>
											<gml:Envelope srsName="urn:x-ogc:def:crs:EPSG:6.11:4326">
												<gml:lowerCorner>-180.0 -90.0</gml:lowerCorner>
												<gml:upperCorner>180.0 90.0</gml:upperCorner>
											</gml:Envelope>
										</ogc:BBOX>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:variable name="nRecords" select="count($response//csw:SearchResults/*)"/>
					<xsl:if test="$nRecords gt 0">
						<ctl:message>[FAILURE] csw:SearchResults should be empty (<xsl:value-of
								select="$nRecords"/> included)</ctl:message>
						<ctl:fail/>
					</xsl:if>
					<xsl:if
						test="xsd:integer($response//csw:SearchResults/@numberOfRecordsMatched) lt 1">
						<ctl:message>[FAILURE] Expected @numberOfRecordsMatched &gt; 0</ctl:message>
						<ctl:fail/>
					</xsl:if>
					<xsl:if test="$response//csw:SearchResults/@nextRecord != 1">
						<ctl:message>[FAILURE] Expected csw:SearchResults/@nextRecord =
							1.</ctl:message>
						<ctl:fail/>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc24.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that specifies resultType="validate" must
			include an Acknowledgement if the request entity is valid. </assertion>
		<code>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="validate">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>full</csw:ElementSetName>
								<csw:Constraint version="1.1.0">
									<ogc:Filter>
										<ogc:PropertyIsLike wildCard="*" singleChar="."
											escapeChar="\">
											<ogc:PropertyName>csw:AnyText</ogc:PropertyName>
											<ogc:Literal>*wololoo*</ogc:Literal>
										</ogc:PropertyIsLike>
									</ogc:Filter>
								</csw:Constraint>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.CSW/>
				</request>
			</xsl:variable>
			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:if test="not($response//csw:Acknowledgement)">
						<ctl:message>[FAILURE] Expected csw:Acknowledgement in
							response.</ctl:message>
						<ctl:fail/>
					</xsl:if>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc25.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that specifies an unsupported outputFormat
			value must include an exception report. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is a valid
			ows:ExceptionReport; (2) the reported exceptionCode is
			"InvalidParameterValue".</comment>
		<code>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results"
							outputFormat="application/xhtml+xml" maxRecords="5">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>summary</csw:ElementSetName>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.OWS/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:call-test name="ctl:SchematronValidatingParser">
						<ctl:with-param name="doc" select="$response"/>
						<ctl:with-param name="schema"
							>sch/ows/1.0.0/ExceptionReport.sch</ctl:with-param>
						<ctl:with-param name="phase">InvalidParameterValuePhase</ctl:with-param>
					</ctl:call-test>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

	<test name="csw:csw-2.0.2-GetRecords-tc26.1">
		<param name="csw.GetRecords.post.url"/>
		<assertion> The response to a GetRecords request that specifies an unsupported outputSchema
			value must include an exception report. </assertion>
		<comment>Pass if all of the following conditions are true: (1) the response is a valid
			ows:ExceptionReport; (2) the reported exceptionCode is
			"InvalidParameterValue".</comment>
		<code>
			<xsl:variable name="response">
				<request>
					<url>
						<xsl:value-of select="$csw.GetRecords.post.url"/>
					</url>
					<method>POST</method>
					<body>
						<csw:GetRecords service="CSW" version="2.0.2" resultType="results"
							outputSchema="http://www.w3.org/2005/Atom" maxRecords="5">
							<csw:Query typeNames="csw:Record">
								<csw:ElementSetName>summary</csw:ElementSetName>
							</csw:Query>
						</csw:GetRecords>
					</body>
					<p:XMLValidatingParser.OWS/>
				</request>
			</xsl:variable>

			<xsl:choose>
				<xsl:when test="not($response/*)">
					<ctl:message>[FAILURE] Missing or invalid response entity.</ctl:message>
					<ctl:fail/>
				</xsl:when>
				<xsl:otherwise>
					<ctl:call-test name="ctl:SchematronValidatingParser">
						<ctl:with-param name="doc" select="$response"/>
						<ctl:with-param name="schema"
							>sch/ows/1.0.0/ExceptionReport.sch</ctl:with-param>
						<ctl:with-param name="phase">InvalidParameterValuePhase</ctl:with-param>
					</ctl:call-test>
				</xsl:otherwise>
			</xsl:choose>
		</code>
	</test>

</ctl:package>
